What is Go good at?
------------------
problem it's trying to solve: google team built. 
they used c++, java and python

each language has it's advantages and disadvantages

c++: high performance, type safety - slow compilation, complex syntax

java: rapid compilation, type safety - complicated ecosystem

python: ease of use - lack of type safety, relatively slow

solution: GO!


Characteristics
---------------
~Fast compliation
~Fully complied 
~Strongly typed 
~Concurrent by default (what does that mean? multithreading was expected)
~Garbage collected
~Simplicity as a core value


So wtf is it good at?
-------------------
+ web services
+ web apps
~ task automation (syntax is almost as light as scripting languages)
~ gui/thick-client (expir)
~ ml
???



Syntax
------
module ~= workspace
init a module go mod init name of module

go recognizes module path

float
:= -> implicit data type
const keyword -> constant
const() -> constant block
: -> create a slice from beginning to end (python)
map[keyType]datatype"{foo:42 }"
struct: type typeOfStruct struct {}

Quirks
-----
packages that aren't being used will throw a compliation error
formatted with tabs
whitespace isn't critical but encouraged
compiler adds semicolons
comiler will complain about unused variables!
pointer data types are available, but they're not absurd
no pointer arith

value of constant must be determined by compile time
implicit type constant & explict
iota resets in each constant block!
iota increments each time the keyword is used

arrays are static
slices are dynamic
slices are built ontop of arrays
slice is kinda like a pointer. all changes to the array and the slice are the same
slice is not a fixed size entity

struct: any type of data we want together. fields are fixed at compile time
end structs multi line init with a comma for the compiler

structs are scoped 

packages! are just directories

you can build
Opinions
--------
 & float

code
------
//how to declare variables
	var i int
	i = 42

	// ^^ is verbose ~~~
	fmt.Println(i)

	var f float32 = 3.14
	fmt.Println(f)
	// also verbose

	firstName := "Zeke"
	fmt.Println(firstName)
	//most of the time you want to do this

	b := true
	fmt.Println(b)

	c := complex(3, 4)
	fmt.Println(c)
	//complex data types!

	r, im := real(c), imag(c)
	//multiple assignments like python
	fmt.Println(r, im)

	var lastName *string = new(string) //init pointer
	*lastName = "Kei"
	fmt.Println(lastName)
	fmt.Println(*lastName)
	//pointer data type!
	//dereference with an asterix

	dog := "Woof"
	fmt.Println(dog)

	ptr := &dog
	fmt.Println(ptr, *ptr)

	dog = "cat"
	fmt.Println(ptr, *ptr)

	//address of is &

	/*
		iota and constant expressions
	*/
	fmt.Println(pi)
	fmt.Println(first, second, third, fourth, fifth)
	//iota is used? the increments by one
	// you don't have to explicitly called iota all of the time!
	//iota resets in iota blocks

	var arr [3]int
	//here's an array ~ size data type
	//simplify compiler
	arr[0] = 1
	arr[1] = 2
	arr[2] = 3
	fmt.Println(arr)
	//kinda verbose tho
	cats := [3]int{1, 2, 3}
	fmt.Println(cats)

	//slice. array but flexible!

	slice := cats[:]
	//slice
	fmt.Println(slice)
	//slice is pointing to the data in the array

	pizza := []int{1, 2, 3}
	//compiler will know the size for the underlying array
	fmt.Println(pizza)

	pizza = append(pizza, 4, 42, 27)

	fmt.Println(pizza)
	//underlying array is handled by go

	s2 := pizza[1:]
	s3 := pizza[:2]
	//slices of slices
	fmt.Println(s2)
	fmt.Println(s3)
	s4 := pizza[1:2]
	fmt.Println(s4)

	m := map[string]int{"foo": 42}
	//maps m
	fmt.Println(m)
	fmt.Println(m["foo"])

	delete(m, "foo")
	//delete elements
	fmt.Println(m)

	type user struct {
		ID        int
		FirstName string
		LastName  string
	}
	//structs like c?

	var u user
	fmt.Println(u)

	u.ID = 852
	u.FirstName = "Zeke"
	u.LastName = "kei"
	//add data
	fmt.Println(u)

	u2 := user{ID: 777, FirstName: "Zeke", LastName: "kei"}
	fmt.Println(u2)

    const (
	pi     = 3.1415
	first  = 1
	second = iota
	third  = iota
	fourth = 4 << iota
	fifth  = iota + 5
)